<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sculpting the Universe</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #videoElement { display: none; } /* Hidden, only used for tracking */
        canvas { display: block; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <video id="videoElement" autoplay playsinline></video>
    <div id="canvas-container"></div>

<script>
/**
 * PART 1: THREE.JS UNIVERSE SETUP
 */
const container = document.getElementById('canvas-container');
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.001);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
camera.position.z = 400;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
container.appendChild(renderer.domElement);

// Particle System
const particleCount = 20000;
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(particleCount * 3);
const basePositions = new Float32Array(particleCount * 3);
const colors = new Float32Array(particleCount * 3);

const colorPalette = [new THREE.Color(0xffffff), new THREE.Color(0x5588ff), new THREE.Color(0xff66aa)];

for (let i = 0; i < particleCount * 3; i += 3) {
    // Create a sphere/galaxy distribution
    const radius = 200 * Math.cbrt(Math.random()); 
    const theta = Math.random() * 2 * Math.PI;
    const phi = Math.acos((Math.random() * 2) - 1);

    const x = radius * Math.sin(phi) * Math.cos(theta);
    const y = radius * Math.sin(phi) * Math.sin(theta);
    const z = radius * Math.cos(phi);

    positions[i] = x; positions[i+1] = y; positions[i+2] = z;
    basePositions[i] = x; basePositions[i+1] = y; basePositions[i+2] = z;

    const mixedColor = colorPalette[Math.floor(Math.random() * colorPalette.length)];
    colors[i] = mixedColor.r; colors[i+1] = mixedColor.g; colors[i+2] = mixedColor.b;
}

geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geometry.setAttribute('basePosition', new THREE.BufferAttribute(basePositions, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

// Custom Shader Material for GPU-accelerated expansion/collapse
const customMaterial = new THREE.ShaderMaterial({
    uniforms: {
        uTime: { value: 0.0 },
        uState: { value: 0.0 }, // -1 (collapse), 0 (rest), 1 (expand)
    },
    vertexShader: `
        uniform float uTime;
        uniform float uState;
        attribute vec3 basePosition;
        attribute vec3 color;
        varying vec3 vColor;
        
        void main() {
            vColor = color;
            vec3 target = basePosition;
            
            // The magic: pushing and pulling the universe on the GPU
            if (uState < 0.0) {
                target *= mix(1.0, 0.1, -uState); // Collapse to core
            } else if (uState > 0.0) {
                target *= mix(1.0, 2.5, uState);  // Expand outward
            }

            // Slight orbital movement
            float angle = uTime * 0.5 + (length(target) * 0.01);
            mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
            target.xz = rot * target.xz;

            vec4 mvPosition = modelViewMatrix * vec4(target, 1.0);
            gl_PointSize = (150.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }
    `,
    fragmentShader: `
        varying vec3 vColor;
        void main() {
            // Make particles circular with soft edges
            float distanceToCenter = distance(gl_PointCoord, vec2(0.5));
            if (distanceToCenter > 0.5) discard;
            float alpha = 1.0 - (distanceToCenter * 2.0);
            gl_FragColor = vec4(vColor, alpha * 0.8);
        }
    `,
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending
});

const universe = new THREE.Points(geometry, customMaterial);
scene.add(universe);

/**
 * PART 2: STATE & GESTURE LOGIC
 */
let targetRotationX = 0, targetRotationY = 0;
let targetZoom = 400;
let targetState = 0; // The gesture intent: -1, 0, or 1

// Linear Interpolation for buttery smoothness
const lerp = (start, end, factor) => start + (end - start) * factor;

function calculateHandState(landmarks) {
    const wrist = landmarks[0];
    const indexTip = landmarks[8];
    const middleTip = landmarks[12];
    
    // Calculate distance from wrist to fingertips to determine open/closed
    const distIndex = Math.hypot(indexTip.x - wrist.x, indexTip.y - wrist.y);
    const distMiddle = Math.hypot(middleTip.x - wrist.x, middleTip.y - wrist.y);
    const avgDist = (distIndex + distMiddle) / 2;

    if (avgDist < 0.2) return -1.0; // Closed Fist
    if (avgDist > 0.45) return 1.0; // Open Palm
    return 0.0; // Neutral/Resting
}

/**
 * PART 3: MEDIAPIPE INTEGRATION
 */
const videoElement = document.getElementById('videoElement');
const hands = new Hands({
    locateFile: (file) => \`https://cdn.jsdelivr.net/npm/@mediapipe/hands/\${file}\`
});

hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.7
});

hands.onResults((results) => {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        const palm = landmarks[9]; // Base of middle finger, acts as center
        
        // 1. Map Left/Right to Rotation
        targetRotationY = (palm.x - 0.5) * Math.PI * 2; 
        targetRotationX = (palm.y - 0.5) * Math.PI;

        // 2. Map Z (Bounding box width as depth proxy) to Zoom
        const wrist = landmarks[0];
        const indexBase = landmarks[5];
        const handSize = Math.hypot(indexBase.x - wrist.x, indexBase.y - wrist.y);
        targetZoom = 400 + ((0.1 - handSize) * 2000); // Adjust multipliers to taste

        // 3. Map Fingers to Expansion/Gravity
        targetState = calculateHandState(landmarks);
    } else {
        // Return to rest if no hand detected
        targetState = 0;
        targetRotationX = 0;
        targetRotationY = 0;
        targetZoom = 400;
    }
});

const cameraUtils = new Camera(videoElement, {
    onFrame: async () => { await hands.send({image: videoElement}); },
    width: 640, height: 480
});
cameraUtils.start();

/**
 * PART 4: THE RENDER LOOP
 */
const clock = new THREE.Clock();

function animate() {
    requestAnimationFrame(animate);
    
    // Apply inertia and smoothing
    universe.rotation.y = lerp(universe.rotation.y, targetRotationY, 0.05);
    universe.rotation.x = lerp(universe.rotation.x, targetRotationX, 0.05);
    camera.position.z = lerp(camera.position.z, targetZoom, 0.05);
    customMaterial.uniforms.uState.value = lerp(customMaterial.uniforms.uState.value, targetState, 0.1);
    
    customMaterial.uniforms.uTime.value = clock.getElapsedTime();

    renderer.render(scene, camera);
}
animate();

// Handle window resize
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
